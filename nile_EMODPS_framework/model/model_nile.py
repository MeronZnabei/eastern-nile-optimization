# Model class

# Importing libraries for functionality
import os

import numpy as np
import pandas as pd
import networkx as nx
from collections import deque
from array import array

# Importing classes to generate the model
from .model_classes import Reservoir, Catchment, IrrigationDistrict, HydropowerPlant
from .smash import Policy


class ModelNile:
    """
    Model class consists of three major functions. First, static
    components i.e., reservoirs, catchments, policy objects are
    created within the constructor. Evaluate function serves as the
    behaviour generating machine which outputs KPIs of the model.
    Evaluate does so by means of calling the simulate function which
    handles the state transformation via mass-balance equation
    calculations iteratively.
    """

    def __init__(self):
        """
        Creating the static objects of the model including the
        reservoirs, catchments, irrigation districts and policy
        objects along with their parameters. For a specific case
        study, model topology, simulation parameters, model parameters
        and reservoir characteristics are read from the settings file.
        """

        self.policies = None
        self.topology_data = None
        self.reservoir_parameters = None
        # self.decision_list = list()  # Store release decision dicts at each step
        self.synthetic_hydrology = list()
        self.read_synthetic_hydrology("baseline")
        self.total_seconds_per_month = np.empty(0)
        self.total_hours_per_month = np.empty(0)
        self.integ_steps_per_month = np.empty(0)
        self.read_settings_file("../settings/settings_file_Nile_with_icons.xlsm")

        # Generate model topology as a NetworkX object:
        self.model_topology = nx.DiGraph()  # Directed graph (direction of flow)

        # Add all model elements one by one, from the settings file.
        # Dynamically generate specific objects on the go.
        # Also, connect the nodes of the directed graph in the same iteration:
        for _, row in self.topology_data.iterrows():

            network_id = int(row["Network ID"])  # Unique integer for each model object
            obj_type = row["Type"]  # Catchment, reservoir or irrigation district

            # Dynamic model object generation, constructor takes the specific name of the object:
            obj = globals()[obj_type](row["Name"])

            # Check if the network node with desired ID has been generated by a previous object:
            # This is always the case except for source nodes because we generate outgoing link
            # from the previous network node.
            if not self.model_topology.has_node(network_id):
                self.model_topology.add_node(network_id, obj=obj, obj_type=obj_type)
            else:
                self.model_topology.nodes[network_id][
                    "obj"
                ] = obj  # Python object as node attribute
                self.model_topology.nodes[network_id][
                    "obj_type"
                ] = obj_type  # CONSIDER REMOVING!

            try:
                my_link = int(
                    row["Outgoing Nodes"]
                )  # Reads the Node ID of the object it is connected to
                delay = row[
                    "Delay"
                ]  # Delay (in decision steps) between this node and the next one.

                # Each edge on the network stores a dynamic flow value. The data structure used for storage
                # is deque. For the edges that have a delay, deque allows us to convey the older value to the
                # next node. Once a new value is appended to the deque the oldest one drops.
                initial_deque = list()
                if delay > 0:  # Initialization of delayed reach of water to a node
                    initial_deque = eval(row["Initial for Delay"])
                flow_storage = deque(initial_deque, maxlen=delay + 1)

                self.model_topology.add_edge(
                    network_id, my_link, delay=delay, flow=flow_storage
                )

            except ValueError:  # This happens when Outgoing Nodes cannot be cast to int
                print(f"Network node of {obj_type} {row['Name']} is a sink")

        # Initialize some features of reservoirs (dam min/max levels, hydropower parameters) from the settings file:
        for reservoir in self.objects_by_class("Reservoir"):

            # Set initial storage values (based on Excel settings)
            initial_storage = float(
                self.reservoir_parameters.loc[reservoir.name, "Initial Storage(m3)"]
            )
            reservoir.storage_vector.append(initial_storage)

            # Set hydropower production parameters (based on Excel settings)
            variable_names_raw = self.reservoir_parameters.columns[-4:].values.tolist()

            if self.reservoir_parameters.loc[reservoir.name, "Hydropower Exists"]:
                new_plant = HydropowerPlant(reservoir)

                for variable in variable_names_raw:
                    setattr(
                        new_plant,
                        variable.replace(" ", "_").lower(),
                        float(self.reservoir_parameters.loc[reservoir.name, variable]),
                    )
                reservoir.hydropower_plant = new_plant

        # Delete dataframes from memory after initialization
        del self.reservoir_parameters
        del self.topology_data

        # Generate the policy object from the SMASH library
        self.overarching_policy = Policy()

        # Parameter values for the policy are inputted on the Excel settings
        # file. Each policy in the self.policies list is a dictionary with
        # variable name as the key and value as the value.
        for policy in self.policies:
            self.overarching_policy.add_policy_function(**policy)

        # As the policies are initialised, we delete this list from memory
        del self.policies

    def __call__(self, *args, **kwargs):

        lever_count = self.overarching_policy.get_total_parameter_count()
        input_parameters = [kwargs["v" + str(i)] for i in range(lever_count)]

        (
            egypt_def,
            min_HAD,
            sudan_def,
            ethiopia_hydro,
        ) = self.evaluate(
            np.array(input_parameters)
        )

        return egypt_def, min_HAD, sudan_def, ethiopia_hydro

    def evaluate(self, parameter_vector):
        """Evaluate the KPI values based on given input
        data and policy parameter configuration. Calls simulation
        once or multiple times depending on how many synthetic
        hydrology realizations were read during the model initialization

        Parameters
        ----------
        self : ModelZambezi object
        parameter_vector : np.array
            Parameter values for the reservoir control policy
            object (NN, RBF etc.)

        Returns
        -------
        objective_values : list
            Calculated objective values
        """

        self.overarching_policy.assign_free_parameters(parameter_vector)

        objectives = ["egypt_def", "min_HAD", "sudan_def", "ethiopia_hydro"]
        objective_values = {objective: array("f", []) for objective in objectives}

        for realization in self.synthetic_hydrology:

            self.assign_streamflow_to_catchments(realization)
            self.reset_parameters()
            self.simulate()

            bcm_def_egypt = [
                month * 3600 * 24 * self.nu_of_days_per_month[i % 12] * 1e-9
                for i, month in enumerate(self.object_by_name("Egypt").deficit)
            ]
            egypt_def = np.sum(bcm_def_egypt) / 20

            min_HAD = np.min(self.object_by_name("HAD").level_vector)

            sudan_irr_districts = [
                irr_district
                for irr_district in self.objects_by_class("IrrigationDistrict")
                if irr_district.name != "Egypt"
            ]
            sudan_agg_def_vector = np.repeat(0.0, self.simulation_horizon)
            for district in sudan_irr_districts:
                sudan_agg_def_vector += district.deficit
            bcm_def_sudan = [
                month * 3600 * 24 * self.nu_of_days_per_month[i % 12] * 1e-9
                for i, month in enumerate(sudan_agg_def_vector)
            ]
            sudan_def = np.sum(bcm_def_sudan) / 20

            ethiopia_hydro = (
                np.sum(self.object_by_name("GERD").hydroenergy_produced)
            ) / (20 * 1e6)

            for objective in objectives:
                objective_values[objective].append(locals()[objective])

        return (
            np.mean(objective_values["egypt_def"]),
            np.mean(objective_values["min_HAD"]),
            np.mean(objective_values["sudan_def"]),
            np.mean(objective_values["ethiopia_hydro"]),
        )

    def simulate(self):
        """
        Mathematical simulation over the specified simulation
        duration within a main for loop based on the mass-balance
        equations. Mass-balance equations are not explicitly coded, simulation logic works for any model topology.
        """
        # Initial value for the total inflow (to be used in policy)
        total_monthly_inflow = self.inflowTOT00

        for t in np.arange(self.simulation_horizon):

            moy = (self.init_month + t - 1) % 12 + 1  # Current month
            total_hours = self.total_hours_per_month[moy - 1]
            total_seconds = self.total_seconds_per_month[moy - 1]
            integ_step = self.integ_steps_per_month[moy - 1]

            # add the inputs for the policy function (NN, RBF)

            storages = [
                reservoir.storage_vector[t]
                for reservoir in self.objects_by_class("Reservoir")
            ]
            # In addition to storages, month of the year and total inflow
            # values are used by the policy function:
            policy_input = storages + [moy, total_monthly_inflow]

            uu = self.overarching_policy.functions["release"].get_output_norm(
                np.array(policy_input)
            )  # Policy function is called here!

            decision_dict = {
                reservoir.name: uu[index]
                for index, reservoir in enumerate(self.objects_by_class("Reservoir"))
            }

            #self.decision_list.append(decision_dict)

            # Roll-over the model topology to calculate the mass-balances automatically
            for node_id, obj in self.model_topology.nodes(data="obj"):
                if node_id == 0:
                    total_inflow = 0
                # Find my incoming edges, access their flow deque (last item of a tuple) get their latest value[0]
                else:
                    inflows = [
                        inflow[-1][0]
                        for inflow in list(
                            self.model_topology.in_edges([node_id], data="flow")
                        )
                    ]
                    total_inflow = sum(inflows)
                    # To account for channel losses, we assume a five percent evaporation
                    # after the Atbara river joins the main Nile; hence, a drop in Hassanab
                    # inflow by 5 percent
                    if obj.name == "Hassanab":
                        total_inflow *= 0.95

                object_type = type(obj).__name__

                if object_type == "Catchment":
                    outflow = total_inflow + obj.streamflow[t]

                elif object_type == "Reservoir":
                    outflow = obj.integration(
                        total_seconds,
                        decision_dict[obj.name],
                        total_inflow,
                        moy,
                        integ_step,
                    )
                    # Hydroenergy objective
                    try:
                        hydroenergy_production = (
                            obj.hydropower_plant.calculate_hydroenergy_production(
                                outflow,
                                obj.level_vector[-1],
                                total_hours,
                            )
                        )

                        obj.hydroenergy_produced.append(hydroenergy_production)
                    except AttributeError:  # If there is no hydropower on the reservoir
                        pass

                elif object_type == "IrrigationDistrict":
                    obj.incoming_flow.append(total_inflow)
                    if obj.name != "Egypt":
                        received_flow = self.overarching_policy.functions[f"hedging_{obj.name}"].get_output([total_inflow, obj.demand[t]])
                    else:
                        received_flow = min(total_inflow, obj.demand[t])
                    obj.received_flow.append(received_flow)
                    outflow = total_inflow - received_flow
                    # Monthly deficit in m3/s:
                    obj.deficit.append(self.deficit_from_target(received_flow, obj.demand[t]))

                try:
                    outflow_deque = list(
                        self.model_topology.out_edges([node_id], data="flow")
                    )[0][-1]
                    outflow_deque.append(outflow)
                except IndexError:  # Sink node not finding out edge
                    pass

            total_monthly_inflow = sum(
                [x.streamflow[t] for x in self.objects_by_class("Catchment")]
            )

    @staticmethod
    def deficit_from_target(realisation, target):
        """
        Calculates the deficit given the realisation of an
        objective and the target
        """
        return max(0, target - realisation)

    def reset_parameters(self):

        for reservoir in self.objects_by_class("Reservoir"):
            # Leaving only the initial value in the storages
            reservoir.storage_vector = reservoir.storage_vector[:1]
            # Resetting all other vectors:
            attributes = [
                "level_vector",
                "release_vector",
                "hydroenergy_produced",
                "inflow_vector"
            ]
            for var in attributes:
                setattr(reservoir, var, array("f", []))

        for irr_district in self.objects_by_class("IrrigationDistrict"):
            attributes = ["received_flow", "deficit", "incoming_flow"]
            for var in attributes:
                setattr(irr_district, var, array("f", []))

        # We need to reset the delayed flow, so that the node next to it
        # doesn't use the value remaining from the previous run:
        # From Merowe (13) to HAD (14) (Could have been nicer, conditioned on
        # input Excel but I'm moving forward with this one now!)
        self.model_topology[13][14]["flow"] = deque([1459.1], maxlen=2)

    def read_settings_file(self, filepath):

        model_parameters = pd.read_excel(filepath, sheet_name="ModelParameters")
        for _, row in model_parameters.iterrows():
            name = row["in Python"]
            if row["Data Type"] == "str":
                value = row["Value"]
            else:
                value = eval(str(row["Value"]))
            if row["Data Type"] == "np.array":
                value = np.array(value)
            setattr(self, name, value)

        def return_integ_step(total_seconds, verbal_step, nu_days):
            if verbal_step == "once-a-month":
                step = total_seconds
            elif verbal_step == "weekly":
                step = total_seconds / 4
            elif verbal_step == "daily":
                step = total_seconds / nu_days
            elif verbal_step == "12-hours":
                step = total_seconds / (nu_days * 2)
            elif verbal_step == "6-hours":
                step = total_seconds / (nu_days * 4)
            elif verbal_step == "hourly":
                step = total_seconds / (nu_days * 24)
            elif verbal_step == "half-an-hour":
                step = total_seconds / (nu_days * 48)

            return step

        for nu_days in self.nu_of_days_per_month:
            total_hours = nu_days * 24
            total_seconds = total_hours * 3600
            self.total_hours_per_month = np.append(
                self.total_hours_per_month, total_hours
            )
            self.total_seconds_per_month = np.append(
                self.total_seconds_per_month, total_seconds
            )
            self.integ_steps_per_month = np.append(
                self.integ_steps_per_month,
                return_integ_step(total_seconds, self.integration_interval, nu_days),
            )

        self.topology_data = pd.read_excel(filepath, sheet_name="Topology")
        self.reservoir_parameters = pd.read_excel(
            filepath, sheet_name="ReservoirParameters"
        )
        self.reservoir_parameters.set_index("Reservoir Name", inplace=True)

        self.policies = list()
        full_df = pd.read_excel(filepath, sheet_name="PolicyParameters")
        split_points = list(full_df.loc[full_df["Parameter Name"] == "Name"].index)

        for i in range(len(split_points)):
            try:
                one_policy = full_df.iloc[split_points[i]: split_points[i + 1], :]
            except IndexError:
                one_policy = full_df.iloc[split_points[i]:, :]
            input_dict = dict()

            for _, row in one_policy.iterrows():
                key = row["in Python"]
                if row["Data Type"] != "str":
                    value = eval(str(row["Value"]))
                else:
                    value = row["Value"]
                if row["Data Type"] == "np.array":
                    value = np.array(value)
                input_dict[key] = value

            self.policies.append(input_dict)

    def objects_by_class(self, query_class):
        # Returns a list of objects
        query = [
            obj
            for _, obj in self.model_topology.nodes(data="obj")
            if type(obj).__name__ == query_class
        ]
        if len(query) == 0:
            raise NameError("Asked class name doesn't exist")
        else:
            return query

    def object_by_name(self, name):
        # Returns a single item with the name
        query = [
            obj for _, obj in self.model_topology.nodes(data="obj") if obj.name == name
        ]
        if len(query) == 1:
            return query[0]
        else:
            raise NameError("Asked object name doesn't exist")

    def assign_streamflow_to_catchments(self, flow_df):
        for catchment in self.objects_by_class("Catchment"):
            catchment.streamflow = np.array(flow_df[catchment.name])

    def read_synthetic_hydrology(self, scenario_folder):
        directory = f"../synthetic_hydrology/{scenario_folder}"
        list_of_files = [file for file in os.listdir(directory) if file[-4:] == ".csv"]
        for realization in list_of_files:
            hydro_df = pd.read_csv(f"{directory}/{realization}")
            self.synthetic_hydrology.append(hydro_df)
